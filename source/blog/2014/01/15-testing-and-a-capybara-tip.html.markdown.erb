---
title: Testing and a Capybara tip
date: 2014-01-15 17:16 EST
---
When I first started learning Ruby one of the things that I read and heard over
and over again was how great the libraries for testing were. Coming from
C# and .NET, I had spent a lot of time working with [SpecFlow][specflow],
[mb-unit][mbunit], and [Rhino Mocks][rhino-mocks] in a TDD/BDD-ish environment.
I already knew how incredibly useful a good test suite was and how much more
efficient it could allow you to be when it came to making new features and
refactoring old ones.

What I didn't realize, though, was the extent to which Rubyists tested their
applications. In .NET, everything was heavily unit tested. Although we wrote
Cucumber-style specs, they were mainly being used as a more readable alternative
to the plain xUnit-style tests. We stuck with plain old unit tests with mocked
dependencies and relied on manual testing (or sometimes our CI server) to catch
issues with integration. It was a pain.

Meanwhile, plenty of Rubyists had already been using tons of great testing
libraries. What was crazy about it all of it, to me at least, was what they
were able to test with gems like Capybara (or Rack::Test/Webrat before that).
Although I've since managed to pick up the pieces, the revelation that
you could test an entire application (JavaScript included) with straightforward
tests/specs in Ruby blew my mind.

![mind-blown](<%= blog_image 'mind-blown.gif' %> "Totally relevant")

In my newest project, for example, I've been using Capybara with
[Poltergeist][poltergeist]. Whenever I'm using Capybara, I tend to want to
just play with the API. This can be done by just fiddling with my tests and
constantly rerunning them, but I found an even simpler way to just use
Capybara from Pry or IRB with this script (`pry_capybara.rb`):

```ruby
# Simple script to be able to quickly interact with the capybara API from pry

require 'capybara/poltergeist'
Capybara.run_server = false
Capybara.current_driver = :poltergeist
include Capybara::DSL
```

Capybara will complain about being included in the global scope, but as long as
you are just using this for one-off Pry sessions, it shouldn't matter. You can
use it like this:

```ruby
pry(main)> require_relative 'pry_capybara'
including Capybara::DSL in the global scope is not recommended!
=> true

pry(main)> # if you are running your server locally
pry(main)> visit 'http://localhost:3000'
=> {"status"=>"success"}
pry(main)> title
=> "MyApp"

pry(main)> # or if you want to just mess around with any site
pry(main)> visit 'https://news.ycombinator.com'
=> {"status"=>"success"}
pry(main)> all('.title > a').map(&:text).first(5)
=> ["Super successful companies",
 "Show HN: Kimono â€“ Never write a web scraper again",
 "The Productivity Cycle",
 "Coming soon: Stripe CTF3, distributed systems edition",
 "List of languages that compile to JS"]
```

Although it's small and very simple, it's been really useful to me for when I'm
writing feature specs and (soon to be discussed in another post) page objects.

I know what you must be thinking by now though...
> "It's 2014! We've been doing this kind of thing for years! We're
> even doing this in JavaScript now! Get with the times!"

Although you'd be right to think such a thing, it's still a bit crazy how
powerful libraries like these are. And this is only for testing. Don't even get
me started on the ridiculousness of the [origami-image-folding][oridomi],
[fart-scrolling][fartscroll], [first-person-shooter'ing][bananabread] that
is the current state of JavaScript.

[specflow]: http://www.specflow.org/
[mbunit]: https://code.google.com/p/mb-unit/
[rhino-mocks]: https://github.com/ayende/rhino-mocks
[poltergeist]: https://github.com/jonleighton/poltergeist
[oridomi]: http://oridomi.com/
[fartscroll]: http://theonion.github.io/fartscroll.js/
[bananabread]: https://developer.mozilla.org/en-US/demos/detail/bananabread
