---
title: Page objects with SitePrism
date: 2014-01-16 18:02 EST
---
If you read my last post then you probably already know that I'm a fan of
Capybara. As much as I like it, though, it can be difficult to follow specs
that rely on intimate details of the view in order to determine the success or
failure of a test case. Here's a really simple snippet from a feature spec of
a recent project (`spec/features/sign_up_spec.rb`):

```ruby
feature 'sign up page' do
  # Specific strings or phrases that are used to interact with the page
  # are consolidated in case they change later on.
  given(:signup_path) { '/signup' }
  given(:create_account) { 'Create account' }
  given(:signup) { 'Sign up' }

  background { visit signup_path }

  scenario { expect(page).to have_title signup }
  scenario { expect(page).to have_no_link signup, href: signup_path }

  scenario 'with valid credentials' do
    password = 'password'

    within '#signup' do
      fill_in '#user_email', with: 'foo@bar.com'
      fill_in '#user_password', with: password
      fill_in '#user_password_confirmation', with: password
      click_on create_account
    end

    expect(current_path).to eql('/')
    expect(page).to have_selector('.alert-success')
  end

  scenario 'with invalid credentials' do
    click_on create_account

    expect(current_path).to eql(signup_path)
    expect(page).to have_selector('.alert-warning')
  end
end
```

I'm using the Capybara acceptance test syntax (I think it's more practical
than using Cucumber). I'm only testing a few things here. To summarize the
intent of the specs in plain English:

- When the user visits the sign up page...
  - It should have the right title.
  - There should not be a button linking to the same sign up page.
  - And creates an account with...
      - Valid information he/she should be redirected to the main (root) page
      and notified that the process was a success.
      - Invalid information he/she should stay on the signup page and be
      warned that the process was unsuccessful.

Fairly standard, right? So what's the problem here, then? Well, you may not
have caught it but the actual specs on their own don't really speak to my intent.
What can I do to fix it though?

If I really wanted to incorporate my intent into the tests I could break them
down more and give them better descriptions. For instance, the
`invalid credentials` scenario, redux:

```ruby
feature 'sign up page' do

  ...

  feature 'with invalid credentials' do
    background { click_on create_account }

    scenario 'returns to the signup page' do
      expect(current_path).to eql(signup_path)
    end

    scenario 'is warned that it was a failure' do
      expect(page).to have_selector('.alert-warning')
    end
  end
end
```

This seems a little better. It fits with the 'one assertion/expectation per
test' mantra that tends to be a good heuristic. Now if one of these expectations
failed I would at least have a good description to remind me of what the
test was for and what I would need to do to fix it.

There are still a few problems though. What is `'.alert-warning'` all about?
If you've worked with Bootstrap then you probably know, otherwise you could just
guess and maybe take a look at the views later to find out. What about all
of those strings that are consolidated at the start? It's a little strange, too,
but necessary in case the view changes and our points of interaction are no longer
there. A similar thing could probably be done with the alert selectors...

Overall, though, this is still pretty unsatisfactory. All I care about with
this spec is if the feature is intact. The specifics of the view that are
involved are ancillary to the work I am trying to do here. This is where
page objects can come in handy.

After reading one of Thoughtbot's [posts][tb-post] about page objects, I decided
to see if it could help me. At first I tried to make my own simple base page
object but I quickly decided that it would be easier to just see what libraries
were available rather than trying to invent [yet another][lolpageobject].
The one I ended up using is called [SitePrism][siteprism] (there is also
[page-object][pageobject] but I'm not sure if it works with Poltergeist).

With a page object representing the sign up page, I could write my specs like so:

```ruby
feature 'sign up page' do
  given!(:app) { Pages::App.new }
  given!(:signup_page) { app.signup }

  background do
    signup_page.load
    expect(signup_page).to be_logged_out
  end

  scenario { expect(signup_page).to have_correct_title }
  scenario { expect(signup_page).to have_no_signup_button }

  scenario 'with valid credentials' do
    signup_page.fill_in_form(valid: true)
    signup_page.create_account

    expect(signup_page).to have_success_message
    expect(signup_page).to be_logged_in
    expect(app.home).to be_displayed
  end

  scenario 'with invalid credentials' do
    signup_page.fill_in_form(valid: false)
    signup_page.create_account

    expect(signup_page).to have_alert_message
    expect(signup_page).to be_logged_out
    expect(signup_page).to be_displayed
  end

  ...

end
```

Much more readable and to the point. I've deviated from the previous example
and grouped my expectations together again. In this case I feel, however, I think
that it's more acceptable since each line maps directly to one of my intentions
for this feature.

As far as the actual page object goes, my base page object is actually doing
most of the work here since the majority of the logic isn't limited to just
the sign up page (it is used in a login page too, for example). It looks like
this:

```ruby
class Pages::Base < SitePrism::Page
  MESSAGES = %i[notice alert success error]
  ACTIONS = %i[signup login logout]

  attr_reader :expected_title

  def initialize(expected_title:)
    @expected_title = expected_title
  end

  def has_correct_title?
    has_title?(@expected_title)
  end

  MESSAGES.each do |m|
    element("#{m}_message", ".alert-#{m}")
  end

  ACTIONS.each do |action|
    element :"#{action}_button", ".#{action}-btn"
  end

  def logged_in?
    has_logout_button? && has_no_login_button? && has_no_signup_button?
  end

  def logged_out?
    (has_signup_button? || has_login_button?) && has_no_logout_button?
  end
end
```

The rest is handled by the sign up page object.

```ruby
module Pages::Users
  class Signup < Pages::Base
    FORM = '#signup-form'

    SIGNUP_FIELDS = %i[email password password_confirmation]

    VALID_FORM_DATA = {email: 'foo@bar.com',
                       password: 'password',
                       password_confirmation: 'password'}

    INVALID_FORM_DATA = SIGNUP_FIELDS.map { |f| [f, SecureRandom.hex(3)] }.to_h

    set_url '/signup'
    set_url_matcher(/signup/)

    SIGNUP_FIELDS.each do |f|
      element :"#{f}_field", "#user_#{f}"
    end

    element :submit_button, "#{FORM} input[type='submit']"

    def fill_in_form(valid: true)
      data = valid ? VALID_FORM_DATA : INVALID_FORM_DATA
      fields.each { |f, i| i.set(data[f]) }
    end

    def fields
      SIGNUP_FIELDS.map { |f| [f, send(:"#{f}_field")] }.to_h
    end

    def create_account
      submit_button.click
    end
  end
end
```

And finally, the `App` object:

```ruby
module Pages
  class App
    def home
      Home.new(expected_title: 'Home')
    end

    def signup
      Users::Signup.new(expected_title: 'Sign up')
    end
  end
end
```

At this point, I bet I know what you're thinking...

> Yeah well this is great and all but it's also so much more work for that simple
> initial spec! It would have been easier to just keep it the way it was. All
> you've done is moved your coupling to the view into a different file and tripled
> the number of lines of code in the process. But I guess the feature spec is more
> readable... Hmmm...

And that's exactly the point. I have just moved the details of the view. One
key difference, though, is that I've moved them out of a place where they aren't
at all the focal point and don't belong (the feature spec). Where they
have been moved to, meanwhile, is designed specifically for them. The result of
this effort is not just more readable specs, however. I've also encapsulated
application-wide behavior with the `Base` page object (remember those `'.alert'`
selectors?) and gained a great deal of reusability across feature specs. Finally,
I've also made the tests easier to expand in the future, which will inevitably
happen (it did for me and my application is still pretty small at this point in
time).

Anyway, that about wraps this one up. I had fun learning about page objects
and incorporating them into my project and they have already paid off with some
of my recent refactorings (even in my project's JavaScript). Hopefully you got
something useful out of this too!

[tb-post]: http://robots.thoughtbot.com/better-acceptance-tests-with-page-objects
[siteprism]: https://github.com/natritmeyer/site_prism
[lolpageobject]: https://www.ruby-toolbox.com/projects/fucking-page-objects
[pageobject]: https://github.com/cheezy/page-object
